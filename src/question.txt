coding test：
 coding test目标
 请说明项目打包和执行的方式
 请说明发布的方法
 不限语言和平台

 如有问题，请随时电话沟通
 即使你的项目无法打包执行，请仍然提交您的代码
 请确保您的github是公共可访问的

 1、问题：
 F(n) = F(n-1) + F(n-2), where F1 =1, F2 = 2
 F1 =1
 F2 =1
 F3 =2
 F4 =3
 F5 =5
 F6 =8
 F7 =13
 F8 =21
 F9 =34
 F10=55
 F11=89
 F12=144
 可见index=12的F12是第一个包含3个数字的Fn，那么第一个包含1000个数字的Fn的index是多少？

    答：4782，详细代码运行情况请执行FeiBoText.java


 2、将1，2，3，4， .....，99，100的顺序数列，排序成 100，1，99，2，98，3，......，51，50这样的非等差数列。
    要求:空间复杂度o(1)，时间复杂度o(n)。

    答：详细代码运行情况请执行LinkedListSortTest.java

 3、素数是自然数中大于1，且只能被正整数中的1和自身整除的自然数。
 比如10以下的素数和为 ：2 + 3 + 5 + 7 = 17
 请计算2,000,000以下的所有素数和

    答：142913828922  详细代码运行情况请执行PrimeText.java

 4、排序算法的平均时间复杂度的下限是多少？请尝试证明您的观点
    答：一个数组在未排列之前排列方式有n!种，
        当经过一次比较，确定其中两个元素的位置后，剩余的排列方式还有n!/2种，
        依次类推，经过m次比较，剩余的排列方式为n!/(2^m)种。
        当n!/(2^m)<1时，即满足了排序完成，目前即要证明m为多少时能满足这个条件。
        对n!/(2^m)<1 转换得：
            k>log(n!);
            根据斯特林公式知道lg(n!)与nlogn是等价无穷大的。
            所以得出k>nlogn;
            所以基于排序的比较算法的的最低时间复杂度是O(nlogn)

 5、目前有线索池系统的需求，需要记录线索来源和线索信息，线索信息的内容除了客户名和多种（至少）一种联系方式外，
 并不明确信息的数量和内容。
 另有下单系统，系统中有客户名和一种联系方式，包含供应商信息等确定的60个不同类型字段。
 线索池的客户名和下单的客户名不一定相同。
 此外还有代理商网咯系统，会得到线索池分发的信息。
 请尝试设计线索池系统，其中下单系统和代理商网络是旧有系统，有一定改造难度。
 总体目标是实现线索有效性的评价，尽可能提高线索的利用率（供应商对线索的有效利用）。


 6、请简述jvm模型，包括并发模型，请至少说明两项不涉及garbage的内容
    答：1、先说说volatile。
        volatile修改的共享变量有两个特性：1、保证不同线程对该变量操作在内存中的可见性。2、禁止指令重排。
        内存可见性：在JMM中，每个java线程都存在着自己的工作内存，线程对变量的读写操作都是在工作内存中完成，不会操作主内存。
                    就是把volatile修饰的变量强制刷新到主内存中。
        指令重排：JMM本身是允许指令重排的，但是规定重排不影响程序执行结果。但在并发环境中，JMM的重排序对导致线程执行出问题。
                  使用volatile确保程序的顺序性。
        2、JMM处理并发过程中如何保存原子性、可见性和有序性的。
           原子性：就是一系列操作要么全执行完，要么不执行。jmm中，基本数据类型的读取和赋值是原子性的。
           可见性：java使用volatile来实现对变量的可见性，就是把变量刷新到主内存中，以便其它线程读取。
           有序性：jmm在单线程中，是会进行指令重排序的，其原则是先行发生原则(happens-before)。
                    以达到最优化的运行效率，但在多线程中我们要使用volatile或其它锁的方式保证程序的有序性。
        3、再说说java线程这块。在多核CPU的服务器中，线程会映射到不同的CPU中进行执行。那我们怎么保证线程安全呢？
           有三种方式
           1、互斥同步：使用synchronized关键字修饰代码块、方法或变量。达到互斥的目地。另外使用JDK中ReentrantLock类来实现同步。
           2、非阴塞同步：使用CAS原则，先比较再替换，先比较“内存中的值”与 拿出来的"旧值"比较，看是否相等，如果相同，则把“旧值”与”新值“交换。
                          不相同，就返回false。
           3、使用ThreadLocal：使用ThreadLocal创建每个线程自己的变量空间，以空间换取时间的方式，解决多线程中相同变量的访问冲突问题。